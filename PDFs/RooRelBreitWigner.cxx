/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            *
 *                                                                           *
 * Authors:                                                                  *
 * Katherine George - University of Liverpool                                *
 * Adrian Bevan QMUL (ported from RptBaseTools to Roo - 2009)                *
 * Code massaged by Giulio Dujany - University of Manchester                 *
 *****************************************************************************/ 

// -- CLASS DESCRIPTION [PDF] --
// relativistic breit wigner with blatt weisskopf form factor dependence.

/*
mean is the mass of the resonance, 
width is its width, 
spin is its spin, 

radius is the interaction radius. The event generator on BaBar, EvtGen, uses a range parameter, of 3.0 GeV^{âˆ’1} ~ 0.6 fm.

The parameters massa and massb are the masses of the daughters of the decaying resonance.


 */

#include "Riostream.h" 

#include "RooRelBreitWigner.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(RooRelBreitWigner) 

 RooRelBreitWigner::RooRelBreitWigner(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _mean,
                        RooAbsReal& _width,
                        RooAbsReal& _spin,
                        RooAbsReal& _radius,
                        RooAbsReal& _massa,
                        RooAbsReal& _massb) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   mean("mean","mean",this,_mean),
   width("width","width",this,_width),
   spin("spin","spin",this,_spin),
   radius("radius","radius",this,_radius),
   massa("massa","massa",this,_massa),
   massb("massb","massb",this,_massb)
 { 
 } 


 RooRelBreitWigner::RooRelBreitWigner(const RooRelBreitWigner& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   mean("mean",this,other.mean),
   width("width",this,other.width),
   spin("spin",this,other.spin),
   radius("radius",this,other.radius),
   massa("massa",this,other.massa),
   massb("massb",this,other.massb)
 { 
 }




// Version found in AFit Package: 
// http://pprc.qmul.ac.uk/~bevan/afit/afit.pdf

Double_t RooRelBreitWigner::evaluate() const
{
  Double_t arg= x*x - mean*mean;  
  Double_t gammaf = Gamma();

  if(x < massa+massb) return 0;
  else return x*x / (arg*arg + x*x*gammaf*gammaf);
}


Double_t RooRelBreitWigner::Gamma() const
{
  Double_t kx = KFunction((double)x);
  Double_t km = KFunction(mean);
  Double_t fx = FFunction(radius*kx);
  Double_t fm = FFunction(radius*km);
  Double_t rk = 0.0;
  Double_t rf = 0.0;
  if(km!=0){
    rk = (kx/km);
    if(spin ==1){
      rk = rk*rk*rk;
    }
    if(spin ==2){
      rk = rk*rk*rk*rk*rk;
    }    
  }
  if(fm!=0){
    rf = (fx/fm);
  }
  return width*(mean/x)*rk*rf;
}

Double_t RooRelBreitWigner::FFunction(Double_t X) const
{
  if(spin==0){
      return 1.0;
  }
  if(spin==1){
    return 1.0/(1 + X*X);
  }
  if(spin==2){
    return 1.0/(9 + 3*X*X + X*X*X*X); 
  }
  return 1.0;
}

Double_t RooRelBreitWigner::KFunction(Double_t X) const
{
  if(X==0) return 0;
  Double_t massone = sqrt(1 - (massa + massb)*(massa + massb)/(X*X));
  Double_t masstwo = sqrt(1 - (massa - massb)*(massa - massb)/(X*X));
  return X/2.0 * massone * masstwo;
}


// Alternative version found in:  
// http://svn.cern.ch/guest/lhcb/Erasmus/trunk/PhysFit/RooSimultaneousFitter/src/RooRelBreitWigner.cpp
/*

Double_t RooRelBreitWigner::evaluate() const 
 { 
   Double_t val(0) ;
    if( x > (massa+massb) ) {
        // compute the mass-dependent width
        Double_t gammaf = Gamma() ;

        // compute the BW, taking into account a phase-space factor
        Double_t arg = mean*mean - x*x ;
        val = x * gammaf / (arg*arg + mean * mean * gammaf * gammaf);

        // what we actually still missing is a term that truncates this on
        // the high end. In Bs->JpsiPhi that term would look like
        // p^2Leff+1 where p is the momentum of the j/psi or phi in the 
        // rest frame.
    }
    return val ;
 } 


Double_t RooRelBreitWigner::Gamma() const
{  
    // first compute q(x) and q(m) where q is the momentum of daughters in mother rest frame
    Double_t qm = KFunction(mean);
    Double_t qx = KFunction(x) ;
    Double_t rq = qm>0 ? std::pow( qx/qm, rint( 2*spin + 1 ) ) : 1 ; // this is to 3rd power for spin 1
    // Now compute this radius dependent term
    Double_t rf = 1 ;
    if(radius>0) {
        Double_t fm = FFunction(radius*qm);
        Double_t fx = FFunction(radius*qx);
        rf = (fx/fm);
    } 
    Double_t gammaf = width * (rq * rf * mean / x) ;   
    return gammaf ;
}

Double_t RooRelBreitWigner::FFunction(Double_t X) const
{
    // Blatt-Weisskopf barrier factors.
    if(spin==0){
        return 1.0;
    }
    if(spin==1){
        return 1.0/(1 + X*X);
    }
    if(spin==2){
        return 1.0/(9 + 3*X*X + X*X*X*X); 
    }
    return 1.0;
}


Double_t RooRelBreitWigner::KFunction(Double_t X) const
{
    // this returns q, the momentum of one of the daughters in
    // the rest frame
    Double_t ma = massa ;
    Double_t mb = massb ;
    Double_t q(0) ;
    if( X - ma - mb > 0 ) {
        Double_t ma2 = ma*ma ;
        Double_t mb2 = mb*mb ;
        Double_t Q2 = X*X - ma2 - mb2 ;
        q = std::sqrt( std::abs(Q2*Q2 - 4*ma2*mb2) ) / (2*X) ;
    }
    return q ;
}
*/



